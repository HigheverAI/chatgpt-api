{"version":3,"sources":["../src/chatgpt-api.ts","../src/tokenizer.ts","../src/types.ts","../src/fetch.ts","../src/fetch-sse.ts","../src/stream-async-iterable.ts","../src/chatgpt-unofficial-proxy-api.ts","../src/utils.ts"],"sourcesContent":["import Keyv from 'keyv'\nimport pTimeout from 'p-timeout'\nimport QuickLRU from 'quick-lru'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport * as tokenizer from './tokenizer'\nimport * as types from './types'\nimport { fetch as globalFetch } from './fetch'\nimport { fetchSSE } from './fetch-sse'\n\nconst CHATGPT_MODEL = 'gpt-3.5-turbo'\n\nconst USER_LABEL_DEFAULT = 'User'\nconst ASSISTANT_LABEL_DEFAULT = 'ChatGPT'\n\nexport class ChatGPTAPI {\n  protected _customHeader: { [key: string]: string }\n  protected _customUrl: string\n  protected _apiKey: string\n  protected _apiBaseUrl: string\n  protected _debug: boolean\n\n  protected _customMessages: types.openai.ChatCompletionRequestMessage[] // 添加此行来定义 customMessages 存储\n  protected _systemMessage: string\n  protected _completionParams: Omit<\n    types.openai.CreateChatCompletionRequest,\n    'messages' | 'n'\n  >\n  protected _maxModelTokens: number\n  protected _maxResponseTokens: number\n  protected _fetch: types.FetchFn\n\n  protected _getMessageById: types.GetMessageByIdFunction\n  protected _upsertMessage: types.UpsertMessageFunction\n\n  protected _messageStore: Keyv<types.ChatMessage>\n\n  /**\n   * Creates a new client wrapper around OpenAI's chat completion API, mimicing the official ChatGPT webapp's functionality as closely as possible.\n   *\n   * @param apiKey - OpenAI API key (required).\n   * @param apiBaseUrl - Optional override for the OpenAI API base URL.\n   * @param debug - Optional enables logging debugging info to stdout.\n   * @param completionParams - Param overrides to send to the [OpenAI chat completion API](https://platform.openai.com/docs/api-reference/chat/create). Options like `temperature` and `presence_penalty` can be tweaked to change the personality of the assistant.\n   * @param maxModelTokens - Optional override for the maximum number of tokens allowed by the model's context. Defaults to 4096.\n   * @param maxResponseTokens - Optional override for the minimum number of tokens allowed for the model's response. Defaults to 1000.\n   * @param messageStore - Optional [Keyv](https://github.com/jaredwray/keyv) store to persist chat messages to. If not provided, messages will be lost when the process exits.\n   * @param getMessageById - Optional function to retrieve a message by its ID. If not provided, the default implementation will be used (using an in-memory `messageStore`).\n   * @param upsertMessage - Optional function to insert or update a message. If not provided, the default implementation will be used (using an in-memory `messageStore`).\n   * @param fetch - Optional override for the `fetch` implementation to use. Defaults to the global `fetch` function.\n   */\n  constructor(opts: types.ChatGPTAPIOptions) {\n    const {\n      apiKey,\n      apiBaseUrl = 'https://api.openai.com/v1',\n      debug = false,\n      messageStore,\n      completionParams,\n      systemMessage,\n      maxModelTokens = 4000,\n      maxResponseTokens = 1000,\n      getMessageById,\n      upsertMessage,\n      fetch = globalFetch,\n      customHeader = {},\n      customUrl,\n      customMessages = []\n    } = opts\n\n    this._customMessages = customMessages // 添加此行来初始化 customMessages\n    this._customHeader = customHeader\n    this._customUrl = customUrl\n    this._apiKey = apiKey\n    this._apiBaseUrl = apiBaseUrl\n    this._debug = !!debug\n    this._fetch = fetch\n\n    this._completionParams = {\n      model: CHATGPT_MODEL,\n      temperature: 0.8,\n      top_p: 1.0,\n      presence_penalty: 1.0,\n      ...completionParams\n    }\n\n    this._systemMessage = systemMessage\n\n    if (this._systemMessage === undefined) {\n      const currentDate = new Date().toISOString().split('T')[0]\n      this._systemMessage = `You are ChatGPT, a large language model trained by OpenAI, based on the GPT-4 architecture.\\nKnowledge cutoff: 2023-04\\nCurrent date: ${currentDate}`\n    }\n\n    this._maxModelTokens = maxModelTokens\n    this._maxResponseTokens = maxResponseTokens\n\n    this._getMessageById = getMessageById ?? this._defaultGetMessageById\n    this._upsertMessage = upsertMessage ?? this._defaultUpsertMessage\n\n    if (messageStore) {\n      this._messageStore = messageStore\n    } else {\n      this._messageStore = new Keyv<types.ChatMessage, any>({\n        store: new QuickLRU<string, types.ChatMessage>({ maxSize: 10000 })\n      })\n    }\n\n    if (!this._apiKey) {\n      throw new Error('OpenAI missing required apiKey')\n    }\n\n    if (!this._fetch) {\n      throw new Error('Invalid environment; fetch is not defined')\n    }\n\n    if (typeof this._fetch !== 'function') {\n      throw new Error('Invalid \"fetch\" is not a function')\n    }\n  }\n\n  /**\n   * Sends a message to the OpenAI chat completions endpoint, waits for the response\n   * to resolve, and returns the response.\n   *\n   * If you want your response to have historical context, you must provide a valid `parentMessageId`.\n   *\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\n   *\n   * Set `debug: true` in the `ChatGPTAPI` constructor to log more info on the full prompt sent to the OpenAI chat completions API. You can override the `systemMessage` in `opts` to customize the assistant's instructions.\n   *\n   * @param message - The prompt message to send\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation (defaults to `undefined`)\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\n   * @param opts.systemMessage - Optional override for the chat \"system message\" which acts as instructions to the model (defaults to the ChatGPT system message)\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n   * @param completionParams - Optional overrides to send to the [OpenAI chat completion API](https://platform.openai.com/docs/api-reference/chat/create). Options like `temperature` and `presence_penalty` can be tweaked to change the personality of the assistant.\n   *\n   * @returns The response from ChatGPT\n   */\n  async sendMessage(\n    text: string,\n    opts: types.SendMessageOptions = {}\n  ): Promise<types.ChatMessage> {\n    const {\n      parentMessageId,\n      messageId = uuidv4(),\n      timeoutMs,\n      onProgress,\n      stream = onProgress ? true : false,\n      completionParams,\n      onTransform,\n      onCustomProgress,\n      onCustomResUpsertMessage,\n      onCustomContentFilter\n    } = opts\n\n    let { abortSignal } = opts\n\n    let abortController: AbortController = null\n    if (timeoutMs && !abortSignal) {\n      abortController = new AbortController()\n      abortSignal = abortController.signal\n    }\n\n    const message: types.ChatMessage = {\n      role: 'user',\n      id: messageId,\n      parentMessageId,\n      text\n    }\n    if (onCustomResUpsertMessage) {\n      await onCustomResUpsertMessage(message, this._messageStore)\n    } else {\n      await this._upsertMessage(message)\n    }\n\n    const { messages, maxTokens, numTokens } = await this._buildMessages(\n      text,\n      opts,\n      onCustomContentFilter\n    )\n\n    const result: types.ChatMessage = {\n      role: 'assistant',\n      id: uuidv4(),\n      parentMessageId: messageId,\n      text: ''\n    }\n\n    const responseP = new Promise<types.ChatMessage>(\n      async (resolve, reject) => {\n        const url = this._customUrl ?? `${this._apiBaseUrl}/chat/completions`\n        // const url = `${this._apiBaseUrl}/chat/completions`\n        const headers = {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this._apiKey}`,\n          ...this._customHeader\n        }\n        const body = {\n          max_tokens: maxTokens,\n          ...this._completionParams,\n          ...completionParams,\n          messages,\n          stream\n        }\n        onTransform?.(headers, body)\n        if (this._debug) {\n          console.log(`sendMessage (${numTokens} tokens)`, body)\n        }\n\n        if (stream) {\n          fetchSSE(\n            url,\n            {\n              method: 'POST',\n              headers,\n              body: JSON.stringify(body),\n              signal: abortSignal,\n              onMessage: (data: string) => {\n                data = data.trim();\n                if (onCustomProgress) {\n                  try {\n                    onCustomProgress(JSON.parse(data), result, resolve)\n                  } catch (err) {\n                    console.warn(\n                      'Custom stream SEE event unexpected error',\n                      err\n                    )\n                    return reject(err)\n                  }\n                } else {\n                  if (data === '[DONE]') {\n                    result.text = result.text.trim()\n                    return resolve(result)\n                  }\n\n                  try {\n                    const response: types.openai.CreateChatCompletionDeltaResponse =\n                      JSON.parse(data)\n\n                    if (response.id) {\n                      result.id = response.id\n                    }\n\n                    if (response?.choices?.length) {\n                      const delta = response.choices[0].delta\n                      result.delta = delta.content\n                      if (delta?.content) result.text += delta.content\n                      result.detail = response\n\n                      if (delta.role) {\n                        result.role = delta.role\n                      }\n\n                      onProgress?.(result)\n                    }\n\n                    if (response.usage && result.detail) {\n                      result.detail.usage = response.usage\n                      onProgress?.(result)\n                    }\n                  } catch (err) {\n                    console.warn(\n                      'OpenAI stream SEE event unexpected error',\n                      err\n                    )\n                    return reject(err)\n                  }\n                }\n              }\n            },\n            this._fetch\n          ).catch(reject)\n        } else {\n          try {\n            const res = await this._fetch(url, {\n              method: 'POST',\n              headers,\n              body: JSON.stringify(body),\n              signal: abortSignal\n            })\n\n            if (!res.ok) {\n              const reason = await res.text()\n              const msg = `OpenAI error ${\n                res.status || res.statusText\n              }: ${reason}`\n              const error = new types.ChatGPTError(msg, { cause: res })\n              error.statusCode = res.status\n              error.statusText = res.statusText\n              return reject(error)\n            }\n\n            const response: types.openai.CreateChatCompletionResponse =\n              await res.json()\n            if (this._debug) {\n              console.log(response)\n            }\n\n            if (response?.id) {\n              result.id = response.id\n            }\n\n            if (response?.choices?.length) {\n              const message = response.choices[0].message\n              result.text = message.content\n              if (message.role) {\n                result.role = message.role\n              }\n            } else {\n              const res = response as any\n              return reject(\n                new Error(\n                  `OpenAI error: ${\n                    res?.detail?.message || res?.detail || 'unknown'\n                  }`\n                )\n              )\n            }\n\n            result.detail = response\n\n            return resolve(result)\n          } catch (err) {\n            return reject(err)\n          }\n        }\n      }\n    ).then((message) => {\n      return this._upsertMessage(message).then(() => message)\n    })\n\n    if (timeoutMs) {\n      if (abortController) {\n        // This will be called when a timeout occurs in order for us to forcibly\n        // ensure that the underlying HTTP request is aborted.\n        ;(responseP as any).cancel = () => {\n          abortController.abort()\n        }\n      }\n\n      return pTimeout(responseP, {\n        milliseconds: timeoutMs,\n        message: 'OpenAI timed out waiting for response'\n      })\n    } else {\n      return responseP\n    }\n  }\n\n  get apiKey(): string {\n    return this._apiKey\n  }\n\n  set apiKey(apiKey: string) {\n    this._apiKey = apiKey\n  }\n\n  protected async _buildMessages(\n    text: string,\n    opts: types.SendMessageOptions,\n    onCustomContentFilter: any\n  ) {\n    const {\n      systemMessage = this._systemMessage,\n      customMessages = this._customMessages\n    } = opts\n    let { parentMessageId } = opts\n\n    const userLabel = USER_LABEL_DEFAULT\n    const assistantLabel = ASSISTANT_LABEL_DEFAULT\n\n    const maxNumTokens = this._maxModelTokens - this._maxResponseTokens\n    let messages: types.openai.ChatCompletionRequestMessage[] = []\n\n    if (systemMessage) {\n      messages.push({\n        role: 'system',\n        content: systemMessage\n      })\n    }\n\n    if (customMessages) {\n      messages.push(...customMessages)\n    }\n\n    const systemMessageOffset = messages.length\n    let nextMessages = text\n      ? messages.concat([\n          {\n            role: 'user',\n            content: text,\n            name: opts.name\n          }\n        ])\n      : messages\n    let numTokens = 0\n\n    do {\n      const prompt = nextMessages\n        .reduce((prompt, message) => {\n          const customResult = onCustomContentFilter\n            ? onCustomContentFilter(message)\n            : null\n          if (customResult !== null) {\n            // 有自定义结果，直接使用\n            return prompt.concat(customResult)\n          } else {\n            switch (message.role) {\n              case 'system':\n                return prompt.concat([`Instructions:\\n${message.content}`])\n              case 'user':\n                return prompt.concat([`${userLabel}:\\n${message.content}`])\n              default:\n                return prompt.concat([`${assistantLabel}:\\n${message.content}`])\n            }\n          }\n        }, [] as string[])\n        .join('\\n\\n')\n\n      const nextNumTokensEstimate = await this._getTokenCount(prompt)\n      const isValidPrompt = nextNumTokensEstimate <= maxNumTokens\n\n      if (prompt && !isValidPrompt) {\n        break\n      }\n\n      messages = nextMessages\n      numTokens = nextNumTokensEstimate\n\n      if (!isValidPrompt) {\n        break\n      }\n\n      if (!parentMessageId) {\n        break\n      }\n\n      const parentMessage = await this._getMessageById(parentMessageId)\n      if (!parentMessage) {\n        break\n      }\n\n      const parentMessageRole = parentMessage.role || 'user'\n\n      nextMessages = nextMessages.slice(0, systemMessageOffset).concat([\n        {\n          role: parentMessageRole,\n          content: parentMessage.text,\n          name: parentMessage.name\n        },\n        ...nextMessages.slice(systemMessageOffset)\n      ])\n\n      parentMessageId = parentMessage.parentMessageId\n    } while (true)\n\n    // Use up to 4096 tokens (prompt + response), but try to leave 1000 tokens\n    // for the response.\n    const maxTokens = Math.max(\n      1,\n      Math.min(this._maxModelTokens - numTokens, this._maxResponseTokens)\n    )\n\n    return { messages, maxTokens, numTokens }\n  }\n\n  protected async _getTokenCount(text: string) {\n    // TODO: use a better fix in the tokenizer\n    text = text.replace(/<\\|endoftext\\|>/g, '')\n\n    return tokenizer.encode(text).length\n  }\n\n  protected async _defaultGetMessageById(\n    id: string\n  ): Promise<types.ChatMessage> {\n    const res = await this._messageStore.get(id)\n    return res\n  }\n\n  protected async _defaultUpsertMessage(\n    message: types.ChatMessage\n  ): Promise<void> {\n    await this._messageStore.set(message.id, message)\n  }\n}\n","import { get_encoding } from '@dqbd/tiktoken'\r\n\r\n// TODO: make this configurable\r\nconst tokenizer = get_encoding('cl100k_base')\r\n\r\nexport function encode(input: string): Uint32Array {\r\n  return tokenizer.encode(input)\r\n}\r\n","import Keyv from 'keyv'\n\nexport type Role = 'user' | 'assistant' | 'system'\n\nexport type FetchFn = typeof fetch\n\nexport type ChatGPTAPIOptions = {\n  apiKey: string\n\n  /** @defaultValue `'https://api.openai.com'` **/\n  apiBaseUrl?: string\n\n  /** @defaultValue `false` **/\n  debug?: boolean\n\n  completionParams?: Partial<\n    Omit<openai.CreateChatCompletionRequest, 'messages' | 'n' | 'stream'>\n  >\n\n  systemMessage?: string\n\n  /** @defaultValue `4096` **/\n  maxModelTokens?: number\n\n  /** @defaultValue `1000` **/\n  maxResponseTokens?: number\n\n  messageStore?: Keyv\n  getMessageById?: GetMessageByIdFunction\n  upsertMessage?: UpsertMessageFunction\n\n  fetch?: FetchFn\n\n  customHeader?: { [key: string]: any }\n  customUrl?: string\n  customMessages?: openai.ChatCompletionRequestMessage[]\n}\n\nexport type SendMessageOptions = {\n  /** The name of a user in a multi-user chat. */\n  name?: string\n  parentMessageId?: string\n  messageId?: string\n  stream?: boolean\n  systemMessage?: string\n  timeoutMs?: number\n  onProgress?: (partialResponse: ChatMessage) => void\n  abortSignal?: AbortSignal\n  completionParams?: Partial<\n    Omit<openai.CreateChatCompletionRequest, 'messages' | 'n' | 'stream'>\n  >\n\n  customMessages?: openai.ChatCompletionRequestMessage[]\n  onCustomProgress?: (data: any, result: any, resolve: any) => void\n  onTransform?: (header: any, body: any) => void\n  onCustomResUpsertMessage?: (\n    message: ChatMessage,\n    body: Keyv<ChatMessage>\n  ) => void\n  onCustomContentFilter?: (message: any) => string[] | null\n}\n\nexport type MessageActionType = 'next' | 'variant'\n\nexport type SendMessageBrowserOptions = {\n  conversationId?: string\n  parentMessageId?: string\n  messageId?: string\n  action?: MessageActionType\n  timeoutMs?: number\n  onProgress?: (partialResponse: ChatMessage) => void\n  abortSignal?: AbortSignal\n}\n\nexport interface ChatMessage {\n  id: string\n  text: string\n  role: Role\n  name?: string\n  delta?: string\n  detail?: any\n\n  // relevant for both ChatGPTAPI and ChatGPTUnofficialProxyAPI\n  parentMessageId?: string\n  // only relevant for ChatGPTUnofficialProxyAPI\n  conversationId?: string\n}\n\nexport class ChatGPTError extends Error {\n  statusCode?: number\n  statusText?: string\n  isFinal?: boolean\n  accountId?: string\n}\n\n/** Returns a chat message from a store by it's ID (or null if not found). */\nexport type GetMessageByIdFunction = (id: string) => Promise<ChatMessage>\n\n/** Upserts a chat message to a store. */\nexport type UpsertMessageFunction = (message: ChatMessage) => Promise<void>\n\n/**\n * https://chat.openapi.com/backend-api/conversation\n */\nexport type ConversationJSONBody = {\n  /**\n   * The action to take\n   */\n  action: string\n\n  /**\n   * The ID of the conversation\n   */\n  conversation_id?: string\n\n  /**\n   * Prompts to provide\n   */\n  messages: Prompt[]\n\n  /**\n   * The model to use\n   */\n  model: string\n\n  /**\n   * The parent message ID\n   */\n  parent_message_id: string\n}\n\nexport type Prompt = {\n  /**\n   * The content of the prompt\n   */\n  content: PromptContent\n\n  /**\n   * The ID of the prompt\n   */\n  id: string\n\n  /**\n   * The role played in the prompt\n   */\n  role: Role\n}\n\nexport type ContentType = 'text'\n\nexport type PromptContent = {\n  /**\n   * The content type of the prompt\n   */\n  content_type: ContentType\n\n  /**\n   * The parts to the prompt\n   */\n  parts: string[]\n}\n\nexport type ConversationResponseEvent = {\n  message?: Message\n  conversation_id?: string\n  error?: string | null\n}\n\nexport type Message = {\n  id: string\n  content: MessageContent\n  role: Role\n  user: string | null\n  create_time: string | null\n  update_time: string | null\n  end_turn: null\n  weight: number\n  recipient: string\n  metadata: MessageMetadata\n}\n\nexport type MessageContent = {\n  content_type: string\n  parts: string[]\n}\n\nexport type MessageMetadata = any\n\nexport namespace openai {\n  export interface CreateChatCompletionDeltaResponse {\n    id: string\n    object: 'chat.completion.chunk'\n    created: number\n    model: string\n    choices: [\n      {\n        delta: {\n          role: Role\n          content?: string\n        }\n        index: number\n        finish_reason: string | null\n      }\n    ]\n    usage?: CreateCompletionResponseUsage\n  }\n\n  /**\n   *\n   * @export\n   * @interface ChatCompletionRequestMessage\n   */\n  export interface ChatCompletionRequestMessage {\n    /**\n     * The role of the author of this message.\n     * @type {string}\n     * @memberof ChatCompletionRequestMessage\n     */\n    role: ChatCompletionRequestMessageRoleEnum\n    /**\n     * The contents of the message\n     * @type {string}\n     * @memberof ChatCompletionRequestMessage\n     */\n    content: string\n    /**\n     * The name of the user in a multi-user chat\n     * @type {string}\n     * @memberof ChatCompletionRequestMessage\n     */\n    name?: string\n  }\n  export declare const ChatCompletionRequestMessageRoleEnum: {\n    readonly System: 'system'\n    readonly User: 'user'\n    readonly Assistant: 'assistant'\n  }\n  export declare type ChatCompletionRequestMessageRoleEnum =\n    (typeof ChatCompletionRequestMessageRoleEnum)[keyof typeof ChatCompletionRequestMessageRoleEnum]\n  /**\n   *\n   * @export\n   * @interface ChatCompletionResponseMessage\n   */\n  export interface ChatCompletionResponseMessage {\n    /**\n     * The role of the author of this message.\n     * @type {string}\n     * @memberof ChatCompletionResponseMessage\n     */\n    role: ChatCompletionResponseMessageRoleEnum\n    /**\n     * The contents of the message\n     * @type {string}\n     * @memberof ChatCompletionResponseMessage\n     */\n    content: string\n  }\n  export declare const ChatCompletionResponseMessageRoleEnum: {\n    readonly System: 'system'\n    readonly User: 'user'\n    readonly Assistant: 'assistant'\n  }\n  export declare type ChatCompletionResponseMessageRoleEnum =\n    (typeof ChatCompletionResponseMessageRoleEnum)[keyof typeof ChatCompletionResponseMessageRoleEnum]\n  /**\n   *\n   * @export\n   * @interface CreateChatCompletionRequest\n   */\n  export interface CreateChatCompletionRequest {\n    /**\n     * ID of the model to use. Currently, only `gpt-3.5-turbo` and `gpt-3.5-turbo-0301` are supported.\n     * @type {string}\n     * @memberof CreateChatCompletionRequest\n     */\n    model: string\n    /**\n     * The messages to generate chat completions for, in the [chat format](/docs/guides/chat/introduction).\n     * @type {Array<ChatCompletionRequestMessage>}\n     * @memberof CreateChatCompletionRequest\n     */\n    messages: Array<ChatCompletionRequestMessage>\n    /**\n     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both.\n     * @type {number}\n     * @memberof CreateChatCompletionRequest\n     */\n    temperature?: number | null\n    /**\n     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both.\n     * @type {number}\n     * @memberof CreateChatCompletionRequest\n     */\n    top_p?: number | null\n    /**\n     * How many chat completion choices to generate for each input message.\n     * @type {number}\n     * @memberof CreateChatCompletionRequest\n     */\n    n?: number | null\n    /**\n     * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message.\n     * @type {boolean}\n     * @memberof CreateChatCompletionRequest\n     */\n    stream?: boolean | null\n    /**\n     * Options for streaming response. Only set this when you set stream: true.\n     * @type {CreateChatCompletionRequestStreamOptions}\n     * @memberof CreateChatCompletionRequest\n     */\n    stream_options?: CreateChatCompletionRequestStreamOptions | null\n    /**\n     *\n     * @type {CreateChatCompletionRequestStop}\n     * @memberof CreateChatCompletionRequest\n     */\n    stop?: CreateChatCompletionRequestStop\n    /**\n     * The maximum number of tokens allowed for the generated answer. By default, the number of tokens the model can return will be (4096 - prompt tokens).\n     * @type {number}\n     * @memberof CreateChatCompletionRequest\n     */\n    max_tokens?: number\n    /**\n     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\\'s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details)\n     * @type {number}\n     * @memberof CreateChatCompletionRequest\n     */\n    presence_penalty?: number | null\n    /**\n     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\\'s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details)\n     * @type {number}\n     * @memberof CreateChatCompletionRequest\n     */\n    frequency_penalty?: number | null\n    /**\n     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a json object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.\n     * @type {object}\n     * @memberof CreateChatCompletionRequest\n     */\n    logit_bias?: object | null\n    /**\n     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).\n     * @type {string}\n     * @memberof CreateChatCompletionRequest\n     */\n    user?: string\n  }\n  /**\n   * @type CreateChatCompletionRequestStop\n   * Up to 4 sequences where the API will stop generating further tokens.\n   * @export\n   */\n  export declare type CreateChatCompletionRequestStop = Array<string> | string\n  /**\n   *\n   * @export\n   * @interface CreateChatCompletionResponse\n   */\n  export interface CreateChatCompletionResponse {\n    /**\n     *\n     * @type {string}\n     * @memberof CreateChatCompletionResponse\n     */\n    id: string\n    /**\n     *\n     * @type {string}\n     * @memberof CreateChatCompletionResponse\n     */\n    object: string\n    /**\n     *\n     * @type {number}\n     * @memberof CreateChatCompletionResponse\n     */\n    created: number\n    /**\n     *\n     * @type {string}\n     * @memberof CreateChatCompletionResponse\n     */\n    model: string\n    /**\n     *\n     * @type {Array<CreateChatCompletionResponseChoicesInner>}\n     * @memberof CreateChatCompletionResponse\n     */\n    choices: Array<CreateChatCompletionResponseChoicesInner>\n    /**\n     *\n     * @type {CreateCompletionResponseUsage}\n     * @memberof CreateChatCompletionResponse\n     */\n    usage?: CreateCompletionResponseUsage\n  }\n  /**\n   *\n   * @export\n   * @interface CreateChatCompletionResponseChoicesInner\n   */\n  export interface CreateChatCompletionResponseChoicesInner {\n    /**\n     *\n     * @type {number}\n     * @memberof CreateChatCompletionResponseChoicesInner\n     */\n    index?: number\n    /**\n     *\n     * @type {ChatCompletionResponseMessage}\n     * @memberof CreateChatCompletionResponseChoicesInner\n     */\n    message?: ChatCompletionResponseMessage\n    /**\n     *\n     * @type {string}\n     * @memberof CreateChatCompletionResponseChoicesInner\n     */\n    finish_reason?: string\n  }\n  /**\n   *\n   * @export\n   * @interface CreateCompletionResponseUsage\n   */\n  export interface CreateCompletionResponseUsage {\n    /**\n     *\n     * @type {number}\n     * @memberof CreateCompletionResponseUsage\n     */\n    prompt_tokens: number\n    /**\n     *\n     * @type {number}\n     * @memberof CreateCompletionResponseUsage\n     */\n    completion_tokens: number\n    /**\n     *\n     * @type {number}\n     * @memberof CreateCompletionResponseUsage\n     */\n    total_tokens: number\n  }\n  export interface CreateChatCompletionRequestStreamOptions {\n    /**\n     *\n     * @type {boolean}\n     * @memberof CreateChatCompletionRequestStreamOptions\n     */\n    include_usage: boolean\n  }\n}\n","/// <reference lib=\"dom\" />\r\n\r\nconst fetch = globalThis.fetch\r\n\r\nexport { fetch }\r\n","import { createParser } from 'eventsource-parser'\n\nimport * as types from './types'\nimport { fetch as globalFetch } from './fetch'\nimport { streamAsyncIterable } from './stream-async-iterable'\n\nexport async function fetchSSE(\n  url: string,\n  options: Parameters<typeof fetch>[1] & { onMessage: (data: string) => void },\n  fetch: types.FetchFn = globalFetch\n) {\n  const { onMessage, ...fetchOptions } = options\n  const res = await fetch(url, fetchOptions)\n  if (!res.ok) {\n    let reason: string\n\n    try {\n      reason = await res.text()\n    } catch (err) {\n      reason = res.statusText\n    }\n\n    const msg = `ChatGPT error ${res.status}: ${reason}`\n    const error = new types.ChatGPTError(msg, { cause: res })\n    error.statusCode = res.status\n    error.statusText = res.statusText\n    throw error\n  }\n\n  const parser = createParser((event) => {\n    if (event.type === 'event') {\n      onMessage(event.data)\n    }\n  })\n\n  const decoder = new TextDecoder()\n  if (!res.body.getReader) {\n    // Vercel polyfills `fetch` with `node-fetch`, which doesn't conform to\n    // web standards, so this is a workaround...\n    const body: NodeJS.ReadableStream = res.body as any\n\n    if (!body.on || !body.read) {\n      throw new types.ChatGPTError('unsupported \"fetch\" implementation')\n    }\n\n    body.on('readable', () => {\n      let chunk: string | Buffer\n      while (null !== (chunk = body.read())) {\n        if (typeof chunk === 'string') {\n          parser.feed(chunk.toString())\n        } else {\n          const str = decoder.decode(chunk, { stream: true })\n          parser.feed(str)\n        }\n      }\n    })\n  } else {\n    for await (const chunk of streamAsyncIterable(res.body)) {\n      const str = new TextDecoder().decode(chunk)\n      parser.feed(str)\n    }\n  }\n}\n","export async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\r\n  const reader = stream.getReader()\r\n  try {\r\n    while (true) {\r\n      const { done, value } = await reader.read()\r\n      if (done) {\r\n        return\r\n      }\r\n      yield value\r\n    }\r\n  } finally {\r\n    reader.releaseLock()\r\n  }\r\n}\r\n","import pTimeout from 'p-timeout'\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nimport * as types from './types'\r\nimport { fetch as globalFetch } from './fetch'\r\nimport { fetchSSE } from './fetch-sse'\r\nimport { isValidUUIDv4 } from './utils'\r\n\r\nexport class ChatGPTUnofficialProxyAPI {\r\n  protected _accessToken: string\r\n  protected _apiReverseProxyUrl: string\r\n  protected _debug: boolean\r\n  protected _model: string\r\n  protected _headers: Record<string, string>\r\n  protected _fetch: types.FetchFn\r\n\r\n  /**\r\n   * @param fetch - Optional override for the `fetch` implementation to use. Defaults to the global `fetch` function.\r\n   */\r\n  constructor(opts: {\r\n    accessToken: string\r\n\r\n    /** @defaultValue `https://bypass.duti.tech/api/conversation` **/\r\n    apiReverseProxyUrl?: string\r\n\r\n    /** @defaultValue `text-davinci-002-render-sha` **/\r\n    model?: string\r\n\r\n    /** @defaultValue `false` **/\r\n    debug?: boolean\r\n\r\n    /** @defaultValue `undefined` **/\r\n    headers?: Record<string, string>\r\n\r\n    fetch?: types.FetchFn\r\n  }) {\r\n    const {\r\n      accessToken,\r\n      apiReverseProxyUrl = 'https://bypass.duti.tech/api/conversation',\r\n      model = 'text-davinci-002-render-sha',\r\n      debug = false,\r\n      headers,\r\n      fetch = globalFetch\r\n    } = opts\r\n\r\n    this._accessToken = accessToken\r\n    this._apiReverseProxyUrl = apiReverseProxyUrl\r\n    this._debug = !!debug\r\n    this._model = model\r\n    this._fetch = fetch\r\n    this._headers = headers\r\n\r\n    if (!this._accessToken) {\r\n      throw new Error('ChatGPT invalid accessToken')\r\n    }\r\n\r\n    if (!this._fetch) {\r\n      throw new Error('Invalid environment; fetch is not defined')\r\n    }\r\n\r\n    if (typeof this._fetch !== 'function') {\r\n      throw new Error('Invalid \"fetch\" is not a function')\r\n    }\r\n  }\r\n\r\n  get accessToken(): string {\r\n    return this._accessToken\r\n  }\r\n\r\n  set accessToken(value: string) {\r\n    this._accessToken = value\r\n  }\r\n\r\n  /**\r\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\r\n   * the response.\r\n   *\r\n   * If you want your response to have historical context, you must provide a valid `parentMessageId`.\r\n   *\r\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\r\n   * If you want to receive the full response, including message and conversation IDs,\r\n   * you can use `opts.onConversationResponse` or use the `ChatGPTAPI.getConversation`\r\n   * helper.\r\n   *\r\n   * Set `debug: true` in the `ChatGPTAPI` constructor to log more info on the full prompt sent to the OpenAI completions API. You can override the `promptPrefix` and `promptSuffix` in `opts` to customize the prompt.\r\n   *\r\n   * @param message - The prompt message to send\r\n   * @param opts.conversationId - Optional ID of a conversation to continue (defaults to a random UUID)\r\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation (defaults to `undefined`)\r\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\r\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\r\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\r\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n   *\r\n   * @returns The response from ChatGPT\r\n   */\r\n  async sendMessage(\r\n    text: string,\r\n    opts: types.SendMessageBrowserOptions = {}\r\n  ): Promise<types.ChatMessage> {\r\n    if (!!opts.conversationId !== !!opts.parentMessageId) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: conversationId and parentMessageId must both be set or both be undefined'\r\n      )\r\n    }\r\n\r\n    if (opts.conversationId && !isValidUUIDv4(opts.conversationId)) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: conversationId is not a valid v4 UUID'\r\n      )\r\n    }\r\n\r\n    if (opts.parentMessageId && !isValidUUIDv4(opts.parentMessageId)) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: parentMessageId is not a valid v4 UUID'\r\n      )\r\n    }\r\n\r\n    if (opts.messageId && !isValidUUIDv4(opts.messageId)) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: messageId is not a valid v4 UUID'\r\n      )\r\n    }\r\n\r\n    const {\r\n      conversationId,\r\n      parentMessageId = uuidv4(),\r\n      messageId = uuidv4(),\r\n      action = 'next',\r\n      timeoutMs,\r\n      onProgress\r\n    } = opts\r\n\r\n    let { abortSignal } = opts\r\n\r\n    let abortController: AbortController = null\r\n    if (timeoutMs && !abortSignal) {\r\n      abortController = new AbortController()\r\n      abortSignal = abortController.signal\r\n    }\r\n\r\n    const body: types.ConversationJSONBody = {\r\n      action,\r\n      messages: [\r\n        {\r\n          id: messageId,\r\n          role: 'user',\r\n          content: {\r\n            content_type: 'text',\r\n            parts: [text]\r\n          }\r\n        }\r\n      ],\r\n      model: this._model,\r\n      parent_message_id: parentMessageId\r\n    }\r\n\r\n    if (conversationId) {\r\n      body.conversation_id = conversationId\r\n    }\r\n\r\n    const result: types.ChatMessage = {\r\n      role: 'assistant',\r\n      id: uuidv4(),\r\n      parentMessageId: messageId,\r\n      conversationId,\r\n      text: ''\r\n    }\r\n\r\n    const responseP = new Promise<types.ChatMessage>((resolve, reject) => {\r\n      const url = this._apiReverseProxyUrl\r\n      const headers = {\r\n        ...this._headers,\r\n        Authorization: `Bearer ${this._accessToken}`,\r\n        Accept: 'text/event-stream',\r\n        'Content-Type': 'application/json'\r\n      }\r\n\r\n      if (this._debug) {\r\n        console.log('POST', url, { body, headers })\r\n      }\r\n\r\n      fetchSSE(\r\n        url,\r\n        {\r\n          method: 'POST',\r\n          headers,\r\n          body: JSON.stringify(body),\r\n          signal: abortSignal,\r\n          onMessage: (data: string) => {\r\n            if (data === '[DONE]') {\r\n              return resolve(result)\r\n            }\r\n\r\n            try {\r\n              const convoResponseEvent: types.ConversationResponseEvent =\r\n                JSON.parse(data)\r\n              if (convoResponseEvent.conversation_id) {\r\n                result.conversationId = convoResponseEvent.conversation_id\r\n              }\r\n\r\n              if (convoResponseEvent.message?.id) {\r\n                result.id = convoResponseEvent.message.id\r\n              }\r\n\r\n              const message = convoResponseEvent.message\r\n              // console.log('event', JSON.stringify(convoResponseEvent, null, 2))\r\n\r\n              if (message) {\r\n                let text = message?.content?.parts?.[0]\r\n\r\n                if (text) {\r\n                  result.text = text\r\n\r\n                  if (onProgress) {\r\n                    onProgress(result)\r\n                  }\r\n                }\r\n              }\r\n            } catch (err) {\r\n              // ignore for now; there seem to be some non-json messages\r\n              // console.warn('fetchSSE onMessage unexpected error', err)\r\n            }\r\n          }\r\n        },\r\n        this._fetch\r\n      ).catch((err) => {\r\n        const errMessageL = err.toString().toLowerCase()\r\n\r\n        if (\r\n          result.text &&\r\n          (errMessageL === 'error: typeerror: terminated' ||\r\n            errMessageL === 'typeerror: terminated')\r\n        ) {\r\n          // OpenAI sometimes forcefully terminates the socket from their end before\r\n          // the HTTP request has resolved cleanly. In my testing, these cases tend to\r\n          // happen when OpenAI has already send the last `response`, so we can ignore\r\n          // the `fetch` error in this case.\r\n          return resolve(result)\r\n        } else {\r\n          return reject(err)\r\n        }\r\n      })\r\n    })\r\n\r\n    if (timeoutMs) {\r\n      if (abortController) {\r\n        // This will be called when a timeout occurs in order for us to forcibly\r\n        // ensure that the underlying HTTP request is aborted.\r\n        ;(responseP as any).cancel = () => {\r\n          abortController.abort()\r\n        }\r\n      }\r\n\r\n      return pTimeout(responseP, {\r\n        milliseconds: timeoutMs,\r\n        message: 'ChatGPT timed out waiting for response'\r\n      })\r\n    } else {\r\n      return responseP\r\n    }\r\n  }\r\n}\r\n","const uuidv4Re =\r\n  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\r\n\r\nexport function isValidUUIDv4(str: string): boolean {\r\n  return str && uuidv4Re.test(str)\r\n}\r\n"],"mappings":"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","names":["openai","fetch","fetch","_a","message","res","prompt","pTimeout","uuidv4","fetch","uuidv4","text","pTimeout"]}