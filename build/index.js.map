{"version":3,"sources":["../src/chatgpt-api.ts","../src/tokenizer.ts","../src/types.ts","../src/fetch.ts","../src/fetch-sse.ts","../src/stream-async-iterable.ts","../src/chatgpt-unofficial-proxy-api.ts","../src/utils.ts"],"sourcesContent":["import Keyv from 'keyv'\r\nimport pTimeout from 'p-timeout'\r\nimport QuickLRU from 'quick-lru'\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nimport * as tokenizer from './tokenizer'\r\nimport * as types from './types'\r\nimport { fetch as globalFetch } from './fetch'\r\nimport { fetchSSE } from './fetch-sse'\r\n\r\nconst CHATGPT_MODEL = 'gpt-3.5-turbo'\r\n\r\nconst USER_LABEL_DEFAULT = 'User'\r\nconst ASSISTANT_LABEL_DEFAULT = 'ChatGPT'\r\n\r\nexport class ChatGPTAPI {\r\n  protected _customHeader: { [key: string]: string}\r\n  protected _customUrl: string\r\n  protected _apiKey: string\r\n  protected _apiBaseUrl: string\r\n  protected _debug: boolean\r\n\r\n  protected _systemMessage: string\r\n  protected _completionParams: Omit<\r\n    types.openai.CreateChatCompletionRequest,\r\n    'messages' | 'n'\r\n  >\r\n  protected _maxModelTokens: number\r\n  protected _maxResponseTokens: number\r\n  protected _fetch: types.FetchFn\r\n\r\n  protected _getMessageById: types.GetMessageByIdFunction\r\n  protected _upsertMessage: types.UpsertMessageFunction\r\n\r\n  protected _messageStore: Keyv<types.ChatMessage>\r\n\r\n  /**\r\n   * Creates a new client wrapper around OpenAI's chat completion API, mimicing the official ChatGPT webapp's functionality as closely as possible.\r\n   *\r\n   * @param apiKey - OpenAI API key (required).\r\n   * @param apiBaseUrl - Optional override for the OpenAI API base URL.\r\n   * @param debug - Optional enables logging debugging info to stdout.\r\n   * @param completionParams - Param overrides to send to the [OpenAI chat completion API](https://platform.openai.com/docs/api-reference/chat/create). Options like `temperature` and `presence_penalty` can be tweaked to change the personality of the assistant.\r\n   * @param maxModelTokens - Optional override for the maximum number of tokens allowed by the model's context. Defaults to 4096.\r\n   * @param maxResponseTokens - Optional override for the minimum number of tokens allowed for the model's response. Defaults to 1000.\r\n   * @param messageStore - Optional [Keyv](https://github.com/jaredwray/keyv) store to persist chat messages to. If not provided, messages will be lost when the process exits.\r\n   * @param getMessageById - Optional function to retrieve a message by its ID. If not provided, the default implementation will be used (using an in-memory `messageStore`).\r\n   * @param upsertMessage - Optional function to insert or update a message. If not provided, the default implementation will be used (using an in-memory `messageStore`).\r\n   * @param fetch - Optional override for the `fetch` implementation to use. Defaults to the global `fetch` function.\r\n   */\r\n  constructor(opts: types.ChatGPTAPIOptions) {\r\n    const {\r\n      apiKey,\r\n      apiBaseUrl = 'https://api.openai.com/v1',\r\n      debug = false,\r\n      messageStore,\r\n      completionParams,\r\n      systemMessage,\r\n      maxModelTokens = 4000,\r\n      maxResponseTokens = 1000,\r\n      getMessageById,\r\n      upsertMessage,\r\n      fetch = globalFetch,\r\n      customHeader = {},\r\n\t\t\tcustomUrl\r\n    } = opts\r\n\r\n    this._customHeader = customHeader;\r\n    this._customUrl = customUrl;\r\n    this._apiKey = apiKey\r\n    this._apiBaseUrl = apiBaseUrl\r\n    this._debug = !!debug\r\n    this._fetch = fetch\r\n\r\n    this._completionParams = {\r\n      model: CHATGPT_MODEL,\r\n      temperature: 0.8,\r\n      top_p: 1.0,\r\n      presence_penalty: 1.0,\r\n      ...completionParams\r\n    }\r\n\r\n    this._systemMessage = systemMessage\r\n\r\n    if (this._systemMessage === undefined) {\r\n      const currentDate = new Date().toISOString().split('T')[0]\r\n      this._systemMessage = `You are ChatGPT, a large language model trained by OpenAI. Answer as concisely as possible.\\nKnowledge cutoff: 2021-09-01\\nCurrent date: ${currentDate}`\r\n    }\r\n\r\n    this._maxModelTokens = maxModelTokens\r\n    this._maxResponseTokens = maxResponseTokens\r\n\r\n    this._getMessageById = getMessageById ?? this._defaultGetMessageById\r\n    this._upsertMessage = upsertMessage ?? this._defaultUpsertMessage\r\n\r\n    if (messageStore) {\r\n      this._messageStore = messageStore\r\n    } else {\r\n      this._messageStore = new Keyv<types.ChatMessage, any>({\r\n        store: new QuickLRU<string, types.ChatMessage>({ maxSize: 10000 })\r\n      })\r\n    }\r\n\r\n    if (!this._apiKey) {\r\n      throw new Error('OpenAI missing required apiKey')\r\n    }\r\n\r\n    if (!this._fetch) {\r\n      throw new Error('Invalid environment; fetch is not defined')\r\n    }\r\n\r\n    if (typeof this._fetch !== 'function') {\r\n      throw new Error('Invalid \"fetch\" is not a function')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a message to the OpenAI chat completions endpoint, waits for the response\r\n   * to resolve, and returns the response.\r\n   *\r\n   * If you want your response to have historical context, you must provide a valid `parentMessageId`.\r\n   *\r\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\r\n   *\r\n   * Set `debug: true` in the `ChatGPTAPI` constructor to log more info on the full prompt sent to the OpenAI chat completions API. You can override the `systemMessage` in `opts` to customize the assistant's instructions.\r\n   *\r\n   * @param message - The prompt message to send\r\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation (defaults to `undefined`)\r\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\r\n   * @param opts.systemMessage - Optional override for the chat \"system message\" which acts as instructions to the model (defaults to the ChatGPT system message)\r\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\r\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\r\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n   * @param completionParams - Optional overrides to send to the [OpenAI chat completion API](https://platform.openai.com/docs/api-reference/chat/create). Options like `temperature` and `presence_penalty` can be tweaked to change the personality of the assistant.\r\n   *\r\n   * @returns The response from ChatGPT\r\n   */\r\n  async sendMessage(\r\n    text: string,\r\n    opts: types.SendMessageOptions = {}\r\n  ): Promise<types.ChatMessage> {\r\n    const {\r\n      parentMessageId,\r\n      messageId = uuidv4(),\r\n      timeoutMs,\r\n      onProgress,\r\n      stream = onProgress ? true : false,\r\n      completionParams\r\n    } = opts\r\n\r\n    let { abortSignal } = opts\r\n\r\n    let abortController: AbortController = null\r\n    if (timeoutMs && !abortSignal) {\r\n      abortController = new AbortController()\r\n      abortSignal = abortController.signal\r\n    }\r\n\r\n    const message: types.ChatMessage = {\r\n      role: 'user',\r\n      id: messageId,\r\n      parentMessageId,\r\n      text\r\n    }\r\n    await this._upsertMessage(message)\r\n\r\n    const { messages, maxTokens, numTokens } = await this._buildMessages(\r\n      text,\r\n      opts\r\n    )\r\n\r\n    const result: types.ChatMessage = {\r\n      role: 'assistant',\r\n      id: uuidv4(),\r\n      parentMessageId: messageId,\r\n      text: ''\r\n    }\r\n\r\n    const responseP = new Promise<types.ChatMessage>(\r\n      async (resolve, reject) => {\r\n        const url = this._customUrl ?? `${this._apiBaseUrl}/chat/completions`;\r\n        // const url = `${this._apiBaseUrl}/chat/completions`\r\n        const headers = {\r\n          'Content-Type': 'application/json',\r\n          Authorization: `Bearer ${this._apiKey}`,\r\n          ...this._customHeader\r\n        }\r\n        const body = {\r\n          max_tokens: maxTokens,\r\n          ...this._completionParams,\r\n          ...completionParams,\r\n          messages,\r\n          stream\r\n        }\r\n\r\n        if (this._debug) {\r\n          console.log(`sendMessage (${numTokens} tokens)`, body)\r\n        }\r\n\r\n        if (stream) {\r\n          fetchSSE(\r\n            url,\r\n            {\r\n              method: 'POST',\r\n              headers,\r\n              body: JSON.stringify(body),\r\n              signal: abortSignal,\r\n              onMessage: (data: string) => {\r\n                if (data === '[DONE]') {\r\n                  result.text = result.text.trim()\r\n                  return resolve(result)\r\n                }\r\n\r\n                try {\r\n                  const response: types.openai.CreateChatCompletionDeltaResponse =\r\n                    JSON.parse(data)\r\n\r\n                  if (response.id) {\r\n                    result.id = response.id\r\n                  }\r\n\r\n                  if (response?.choices?.length) {\r\n                    const delta = response.choices[0].delta\r\n                    result.delta = delta.content\r\n                    if (delta?.content) result.text += delta.content\r\n                    result.detail = response\r\n\r\n                    if (delta.role) {\r\n                      result.role = delta.role\r\n                    }\r\n\r\n                    onProgress?.(result)\r\n                  }\r\n                } catch (err) {\r\n                  console.warn('OpenAI stream SEE event unexpected error', err)\r\n                  return reject(err)\r\n                }\r\n              }\r\n            },\r\n            this._fetch\r\n          ).catch(reject)\r\n        } else {\r\n          try {\r\n            const res = await this._fetch(url, {\r\n              method: 'POST',\r\n              headers,\r\n              body: JSON.stringify(body),\r\n              signal: abortSignal\r\n            })\r\n\r\n            if (!res.ok) {\r\n              const reason = await res.text()\r\n              const msg = `OpenAI error ${\r\n                res.status || res.statusText\r\n              }: ${reason}`\r\n              const error = new types.ChatGPTError(msg, { cause: res })\r\n              error.statusCode = res.status\r\n              error.statusText = res.statusText\r\n              return reject(error)\r\n            }\r\n\r\n            const response: types.openai.CreateChatCompletionResponse =\r\n              await res.json()\r\n            if (this._debug) {\r\n              console.log(response)\r\n            }\r\n\r\n            if (response?.id) {\r\n              result.id = response.id\r\n            }\r\n\r\n            if (response?.choices?.length) {\r\n              const message = response.choices[0].message\r\n              result.text = message.content\r\n              if (message.role) {\r\n                result.role = message.role\r\n              }\r\n            } else {\r\n              const res = response as any\r\n              return reject(\r\n                new Error(\r\n                  `OpenAI error: ${\r\n                    res?.detail?.message || res?.detail || 'unknown'\r\n                  }`\r\n                )\r\n              )\r\n            }\r\n\r\n            result.detail = response\r\n\r\n            return resolve(result)\r\n          } catch (err) {\r\n            return reject(err)\r\n          }\r\n        }\r\n      }\r\n    ).then((message) => {\r\n      return this._upsertMessage(message).then(() => message)\r\n    })\r\n\r\n    if (timeoutMs) {\r\n      if (abortController) {\r\n        // This will be called when a timeout occurs in order for us to forcibly\r\n        // ensure that the underlying HTTP request is aborted.\r\n        ;(responseP as any).cancel = () => {\r\n          abortController.abort()\r\n        }\r\n      }\r\n\r\n      return pTimeout(responseP, {\r\n        milliseconds: timeoutMs,\r\n        message: 'OpenAI timed out waiting for response'\r\n      })\r\n    } else {\r\n      return responseP\r\n    }\r\n  }\r\n\r\n  get apiKey(): string {\r\n    return this._apiKey\r\n  }\r\n\r\n  set apiKey(apiKey: string) {\r\n    this._apiKey = apiKey\r\n  }\r\n\r\n  protected async _buildMessages(text: string, opts: types.SendMessageOptions) {\r\n    const { systemMessage = this._systemMessage } = opts\r\n    let { parentMessageId } = opts\r\n\r\n    const userLabel = USER_LABEL_DEFAULT\r\n    const assistantLabel = ASSISTANT_LABEL_DEFAULT\r\n\r\n    const maxNumTokens = this._maxModelTokens - this._maxResponseTokens\r\n    let messages: types.openai.ChatCompletionRequestMessage[] = []\r\n\r\n    if (systemMessage) {\r\n      messages.push({\r\n        role: 'system',\r\n        content: systemMessage\r\n      })\r\n    }\r\n\r\n    const systemMessageOffset = messages.length\r\n    let nextMessages = text\r\n      ? messages.concat([\r\n          {\r\n            role: 'user',\r\n            content: text,\r\n            name: opts.name\r\n          }\r\n        ])\r\n      : messages\r\n    let numTokens = 0\r\n\r\n    do {\r\n      const prompt = nextMessages\r\n        .reduce((prompt, message) => {\r\n          switch (message.role) {\r\n            case 'system':\r\n              return prompt.concat([`Instructions:\\n${message.content}`])\r\n            case 'user':\r\n              return prompt.concat([`${userLabel}:\\n${message.content}`])\r\n            default:\r\n              return prompt.concat([`${assistantLabel}:\\n${message.content}`])\r\n          }\r\n        }, [] as string[])\r\n        .join('\\n\\n')\r\n\r\n      const nextNumTokensEstimate = await this._getTokenCount(prompt)\r\n      const isValidPrompt = nextNumTokensEstimate <= maxNumTokens\r\n\r\n      if (prompt && !isValidPrompt) {\r\n        break\r\n      }\r\n\r\n      messages = nextMessages\r\n      numTokens = nextNumTokensEstimate\r\n\r\n      if (!isValidPrompt) {\r\n        break\r\n      }\r\n\r\n      if (!parentMessageId) {\r\n        break\r\n      }\r\n\r\n      const parentMessage = await this._getMessageById(parentMessageId)\r\n      if (!parentMessage) {\r\n        break\r\n      }\r\n\r\n      const parentMessageRole = parentMessage.role || 'user'\r\n\r\n      nextMessages = nextMessages.slice(0, systemMessageOffset).concat([\r\n        {\r\n          role: parentMessageRole,\r\n          content: parentMessage.text,\r\n          name: parentMessage.name\r\n        },\r\n        ...nextMessages.slice(systemMessageOffset)\r\n      ])\r\n\r\n      parentMessageId = parentMessage.parentMessageId\r\n    } while (true)\r\n\r\n    // Use up to 4096 tokens (prompt + response), but try to leave 1000 tokens\r\n    // for the response.\r\n    const maxTokens = Math.max(\r\n      1,\r\n      Math.min(this._maxModelTokens - numTokens, this._maxResponseTokens)\r\n    )\r\n\r\n    return { messages, maxTokens, numTokens }\r\n  }\r\n\r\n  protected async _getTokenCount(text: string) {\r\n    // TODO: use a better fix in the tokenizer\r\n    text = text.replace(/<\\|endoftext\\|>/g, '')\r\n\r\n    return tokenizer.encode(text).length\r\n  }\r\n\r\n  protected async _defaultGetMessageById(\r\n    id: string\r\n  ): Promise<types.ChatMessage> {\r\n    const res = await this._messageStore.get(id)\r\n    return res\r\n  }\r\n\r\n  protected async _defaultUpsertMessage(\r\n    message: types.ChatMessage\r\n  ): Promise<void> {\r\n    await this._messageStore.set(message.id, message)\r\n  }\r\n}\r\n","import { get_encoding } from '@dqbd/tiktoken'\r\n\r\n// TODO: make this configurable\r\nconst tokenizer = get_encoding('cl100k_base')\r\n\r\nexport function encode(input: string): Uint32Array {\r\n  return tokenizer.encode(input)\r\n}\r\n","import Keyv from 'keyv'\r\n\r\nexport type Role = 'user' | 'assistant' | 'system'\r\n\r\nexport type FetchFn = typeof fetch\r\n\r\nexport type ChatGPTAPIOptions = {\r\n  apiKey: string\r\n\r\n  /** @defaultValue `'https://api.openai.com'` **/\r\n  apiBaseUrl?: string\r\n\r\n  /** @defaultValue `false` **/\r\n  debug?: boolean\r\n\r\n  completionParams?: Partial<\r\n    Omit<openai.CreateChatCompletionRequest, 'messages' | 'n' | 'stream'>\r\n  >\r\n\r\n  systemMessage?: string\r\n\r\n  /** @defaultValue `4096` **/\r\n  maxModelTokens?: number\r\n\r\n  /** @defaultValue `1000` **/\r\n  maxResponseTokens?: number\r\n\r\n  messageStore?: Keyv\r\n  getMessageById?: GetMessageByIdFunction\r\n  upsertMessage?: UpsertMessageFunction\r\n\r\n  fetch?: FetchFn\r\n\r\n  customHeader?: {[key: string]:any};\r\n  customUrl?: string;\r\n}\r\n\r\nexport type SendMessageOptions = {\r\n  /** The name of a user in a multi-user chat. */\r\n  name?: string\r\n  parentMessageId?: string\r\n  messageId?: string\r\n  stream?: boolean\r\n  systemMessage?: string\r\n  timeoutMs?: number\r\n  onProgress?: (partialResponse: ChatMessage) => void\r\n  abortSignal?: AbortSignal\r\n  completionParams?: Partial<\r\n    Omit<openai.CreateChatCompletionRequest, 'messages' | 'n' | 'stream'>\r\n  >\r\n}\r\n\r\nexport type MessageActionType = 'next' | 'variant'\r\n\r\nexport type SendMessageBrowserOptions = {\r\n  conversationId?: string\r\n  parentMessageId?: string\r\n  messageId?: string\r\n  action?: MessageActionType\r\n  timeoutMs?: number\r\n  onProgress?: (partialResponse: ChatMessage) => void\r\n  abortSignal?: AbortSignal\r\n}\r\n\r\nexport interface ChatMessage {\r\n  id: string\r\n  text: string\r\n  role: Role\r\n  name?: string\r\n  delta?: string\r\n  detail?: any\r\n\r\n  // relevant for both ChatGPTAPI and ChatGPTUnofficialProxyAPI\r\n  parentMessageId?: string\r\n  // only relevant for ChatGPTUnofficialProxyAPI\r\n  conversationId?: string\r\n}\r\n\r\nexport class ChatGPTError extends Error {\r\n  statusCode?: number\r\n  statusText?: string\r\n  isFinal?: boolean\r\n  accountId?: string\r\n}\r\n\r\n/** Returns a chat message from a store by it's ID (or null if not found). */\r\nexport type GetMessageByIdFunction = (id: string) => Promise<ChatMessage>\r\n\r\n/** Upserts a chat message to a store. */\r\nexport type UpsertMessageFunction = (message: ChatMessage) => Promise<void>\r\n\r\n/**\r\n * https://chat.openapi.com/backend-api/conversation\r\n */\r\nexport type ConversationJSONBody = {\r\n  /**\r\n   * The action to take\r\n   */\r\n  action: string\r\n\r\n  /**\r\n   * The ID of the conversation\r\n   */\r\n  conversation_id?: string\r\n\r\n  /**\r\n   * Prompts to provide\r\n   */\r\n  messages: Prompt[]\r\n\r\n  /**\r\n   * The model to use\r\n   */\r\n  model: string\r\n\r\n  /**\r\n   * The parent message ID\r\n   */\r\n  parent_message_id: string\r\n}\r\n\r\nexport type Prompt = {\r\n  /**\r\n   * The content of the prompt\r\n   */\r\n  content: PromptContent\r\n\r\n  /**\r\n   * The ID of the prompt\r\n   */\r\n  id: string\r\n\r\n  /**\r\n   * The role played in the prompt\r\n   */\r\n  role: Role\r\n}\r\n\r\nexport type ContentType = 'text'\r\n\r\nexport type PromptContent = {\r\n  /**\r\n   * The content type of the prompt\r\n   */\r\n  content_type: ContentType\r\n\r\n  /**\r\n   * The parts to the prompt\r\n   */\r\n  parts: string[]\r\n}\r\n\r\nexport type ConversationResponseEvent = {\r\n  message?: Message\r\n  conversation_id?: string\r\n  error?: string | null\r\n}\r\n\r\nexport type Message = {\r\n  id: string\r\n  content: MessageContent\r\n  role: Role\r\n  user: string | null\r\n  create_time: string | null\r\n  update_time: string | null\r\n  end_turn: null\r\n  weight: number\r\n  recipient: string\r\n  metadata: MessageMetadata\r\n}\r\n\r\nexport type MessageContent = {\r\n  content_type: string\r\n  parts: string[]\r\n}\r\n\r\nexport type MessageMetadata = any\r\n\r\nexport namespace openai {\r\n  export interface CreateChatCompletionDeltaResponse {\r\n    id: string\r\n    object: 'chat.completion.chunk'\r\n    created: number\r\n    model: string\r\n    choices: [\r\n      {\r\n        delta: {\r\n          role: Role\r\n          content?: string\r\n        }\r\n        index: number\r\n        finish_reason: string | null\r\n      }\r\n    ]\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @export\r\n   * @interface ChatCompletionRequestMessage\r\n   */\r\n  export interface ChatCompletionRequestMessage {\r\n    /**\r\n     * The role of the author of this message.\r\n     * @type {string}\r\n     * @memberof ChatCompletionRequestMessage\r\n     */\r\n    role: ChatCompletionRequestMessageRoleEnum\r\n    /**\r\n     * The contents of the message\r\n     * @type {string}\r\n     * @memberof ChatCompletionRequestMessage\r\n     */\r\n    content: string\r\n    /**\r\n     * The name of the user in a multi-user chat\r\n     * @type {string}\r\n     * @memberof ChatCompletionRequestMessage\r\n     */\r\n    name?: string\r\n  }\r\n  export declare const ChatCompletionRequestMessageRoleEnum: {\r\n    readonly System: 'system'\r\n    readonly User: 'user'\r\n    readonly Assistant: 'assistant'\r\n  }\r\n  export declare type ChatCompletionRequestMessageRoleEnum =\r\n    (typeof ChatCompletionRequestMessageRoleEnum)[keyof typeof ChatCompletionRequestMessageRoleEnum]\r\n  /**\r\n   *\r\n   * @export\r\n   * @interface ChatCompletionResponseMessage\r\n   */\r\n  export interface ChatCompletionResponseMessage {\r\n    /**\r\n     * The role of the author of this message.\r\n     * @type {string}\r\n     * @memberof ChatCompletionResponseMessage\r\n     */\r\n    role: ChatCompletionResponseMessageRoleEnum\r\n    /**\r\n     * The contents of the message\r\n     * @type {string}\r\n     * @memberof ChatCompletionResponseMessage\r\n     */\r\n    content: string\r\n  }\r\n  export declare const ChatCompletionResponseMessageRoleEnum: {\r\n    readonly System: 'system'\r\n    readonly User: 'user'\r\n    readonly Assistant: 'assistant'\r\n  }\r\n  export declare type ChatCompletionResponseMessageRoleEnum =\r\n    (typeof ChatCompletionResponseMessageRoleEnum)[keyof typeof ChatCompletionResponseMessageRoleEnum]\r\n  /**\r\n   *\r\n   * @export\r\n   * @interface CreateChatCompletionRequest\r\n   */\r\n  export interface CreateChatCompletionRequest {\r\n    /**\r\n     * ID of the model to use. Currently, only `gpt-3.5-turbo` and `gpt-3.5-turbo-0301` are supported.\r\n     * @type {string}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    model: string\r\n    /**\r\n     * The messages to generate chat completions for, in the [chat format](/docs/guides/chat/introduction).\r\n     * @type {Array<ChatCompletionRequestMessage>}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    messages: Array<ChatCompletionRequestMessage>\r\n    /**\r\n     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both.\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    temperature?: number | null\r\n    /**\r\n     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both.\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    top_p?: number | null\r\n    /**\r\n     * How many chat completion choices to generate for each input message.\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    n?: number | null\r\n    /**\r\n     * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message.\r\n     * @type {boolean}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    stream?: boolean | null\r\n    /**\r\n     *\r\n     * @type {CreateChatCompletionRequestStop}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    stop?: CreateChatCompletionRequestStop\r\n    /**\r\n     * The maximum number of tokens allowed for the generated answer. By default, the number of tokens the model can return will be (4096 - prompt tokens).\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    max_tokens?: number\r\n    /**\r\n     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\\'s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details)\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    presence_penalty?: number | null\r\n    /**\r\n     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\\'s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details)\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    frequency_penalty?: number | null\r\n    /**\r\n     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a json object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.\r\n     * @type {object}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    logit_bias?: object | null\r\n    /**\r\n     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).\r\n     * @type {string}\r\n     * @memberof CreateChatCompletionRequest\r\n     */\r\n    user?: string\r\n  }\r\n  /**\r\n   * @type CreateChatCompletionRequestStop\r\n   * Up to 4 sequences where the API will stop generating further tokens.\r\n   * @export\r\n   */\r\n  export declare type CreateChatCompletionRequestStop = Array<string> | string\r\n  /**\r\n   *\r\n   * @export\r\n   * @interface CreateChatCompletionResponse\r\n   */\r\n  export interface CreateChatCompletionResponse {\r\n    /**\r\n     *\r\n     * @type {string}\r\n     * @memberof CreateChatCompletionResponse\r\n     */\r\n    id: string\r\n    /**\r\n     *\r\n     * @type {string}\r\n     * @memberof CreateChatCompletionResponse\r\n     */\r\n    object: string\r\n    /**\r\n     *\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionResponse\r\n     */\r\n    created: number\r\n    /**\r\n     *\r\n     * @type {string}\r\n     * @memberof CreateChatCompletionResponse\r\n     */\r\n    model: string\r\n    /**\r\n     *\r\n     * @type {Array<CreateChatCompletionResponseChoicesInner>}\r\n     * @memberof CreateChatCompletionResponse\r\n     */\r\n    choices: Array<CreateChatCompletionResponseChoicesInner>\r\n    /**\r\n     *\r\n     * @type {CreateCompletionResponseUsage}\r\n     * @memberof CreateChatCompletionResponse\r\n     */\r\n    usage?: CreateCompletionResponseUsage\r\n  }\r\n  /**\r\n   *\r\n   * @export\r\n   * @interface CreateChatCompletionResponseChoicesInner\r\n   */\r\n  export interface CreateChatCompletionResponseChoicesInner {\r\n    /**\r\n     *\r\n     * @type {number}\r\n     * @memberof CreateChatCompletionResponseChoicesInner\r\n     */\r\n    index?: number\r\n    /**\r\n     *\r\n     * @type {ChatCompletionResponseMessage}\r\n     * @memberof CreateChatCompletionResponseChoicesInner\r\n     */\r\n    message?: ChatCompletionResponseMessage\r\n    /**\r\n     *\r\n     * @type {string}\r\n     * @memberof CreateChatCompletionResponseChoicesInner\r\n     */\r\n    finish_reason?: string\r\n  }\r\n  /**\r\n   *\r\n   * @export\r\n   * @interface CreateCompletionResponseUsage\r\n   */\r\n  export interface CreateCompletionResponseUsage {\r\n    /**\r\n     *\r\n     * @type {number}\r\n     * @memberof CreateCompletionResponseUsage\r\n     */\r\n    prompt_tokens: number\r\n    /**\r\n     *\r\n     * @type {number}\r\n     * @memberof CreateCompletionResponseUsage\r\n     */\r\n    completion_tokens: number\r\n    /**\r\n     *\r\n     * @type {number}\r\n     * @memberof CreateCompletionResponseUsage\r\n     */\r\n    total_tokens: number\r\n  }\r\n}\r\n","/// <reference lib=\"dom\" />\r\n\r\nconst fetch = globalThis.fetch\r\n\r\nexport { fetch }\r\n","import { createParser } from 'eventsource-parser'\r\n\r\nimport * as types from './types'\r\nimport { fetch as globalFetch } from './fetch'\r\nimport { streamAsyncIterable } from './stream-async-iterable'\r\n\r\nexport async function fetchSSE(\r\n  url: string,\r\n  options: Parameters<typeof fetch>[1] & { onMessage: (data: string) => void },\r\n  fetch: types.FetchFn = globalFetch\r\n) {\r\n  const { onMessage, ...fetchOptions } = options\r\n  const res = await fetch(url, fetchOptions)\r\n  if (!res.ok) {\r\n    let reason: string\r\n\r\n    try {\r\n      reason = await res.text()\r\n    } catch (err) {\r\n      reason = res.statusText\r\n    }\r\n\r\n    const msg = `ChatGPT error ${res.status}: ${reason}`\r\n    const error = new types.ChatGPTError(msg, { cause: res })\r\n    error.statusCode = res.status\r\n    error.statusText = res.statusText\r\n    throw error\r\n  }\r\n\r\n  const parser = createParser((event) => {\r\n    if (event.type === 'event') {\r\n      onMessage(event.data)\r\n    }\r\n  })\r\n\r\n  if (!res.body.getReader) {\r\n    // Vercel polyfills `fetch` with `node-fetch`, which doesn't conform to\r\n    // web standards, so this is a workaround...\r\n    const body: NodeJS.ReadableStream = res.body as any\r\n\r\n    if (!body.on || !body.read) {\r\n      throw new types.ChatGPTError('unsupported \"fetch\" implementation')\r\n    }\r\n\r\n    body.on('readable', () => {\r\n      let chunk: string | Buffer\r\n      while (null !== (chunk = body.read())) {\r\n        parser.feed(chunk.toString())\r\n      }\r\n    })\r\n  } else {\r\n    for await (const chunk of streamAsyncIterable(res.body)) {\r\n      const str = new TextDecoder().decode(chunk)\r\n      parser.feed(str)\r\n    }\r\n  }\r\n}\r\n","export async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\r\n  const reader = stream.getReader()\r\n  try {\r\n    while (true) {\r\n      const { done, value } = await reader.read()\r\n      if (done) {\r\n        return\r\n      }\r\n      yield value\r\n    }\r\n  } finally {\r\n    reader.releaseLock()\r\n  }\r\n}\r\n","import pTimeout from 'p-timeout'\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nimport * as types from './types'\r\nimport { fetch as globalFetch } from './fetch'\r\nimport { fetchSSE } from './fetch-sse'\r\nimport { isValidUUIDv4 } from './utils'\r\n\r\nexport class ChatGPTUnofficialProxyAPI {\r\n  protected _accessToken: string\r\n  protected _apiReverseProxyUrl: string\r\n  protected _debug: boolean\r\n  protected _model: string\r\n  protected _headers: Record<string, string>\r\n  protected _fetch: types.FetchFn\r\n\r\n  /**\r\n   * @param fetch - Optional override for the `fetch` implementation to use. Defaults to the global `fetch` function.\r\n   */\r\n  constructor(opts: {\r\n    accessToken: string\r\n\r\n    /** @defaultValue `https://bypass.duti.tech/api/conversation` **/\r\n    apiReverseProxyUrl?: string\r\n\r\n    /** @defaultValue `text-davinci-002-render-sha` **/\r\n    model?: string\r\n\r\n    /** @defaultValue `false` **/\r\n    debug?: boolean\r\n\r\n    /** @defaultValue `undefined` **/\r\n    headers?: Record<string, string>\r\n\r\n    fetch?: types.FetchFn\r\n  }) {\r\n    const {\r\n      accessToken,\r\n      apiReverseProxyUrl = 'https://bypass.duti.tech/api/conversation',\r\n      model = 'text-davinci-002-render-sha',\r\n      debug = false,\r\n      headers,\r\n      fetch = globalFetch\r\n    } = opts\r\n\r\n    this._accessToken = accessToken\r\n    this._apiReverseProxyUrl = apiReverseProxyUrl\r\n    this._debug = !!debug\r\n    this._model = model\r\n    this._fetch = fetch\r\n    this._headers = headers\r\n\r\n    if (!this._accessToken) {\r\n      throw new Error('ChatGPT invalid accessToken')\r\n    }\r\n\r\n    if (!this._fetch) {\r\n      throw new Error('Invalid environment; fetch is not defined')\r\n    }\r\n\r\n    if (typeof this._fetch !== 'function') {\r\n      throw new Error('Invalid \"fetch\" is not a function')\r\n    }\r\n  }\r\n\r\n  get accessToken(): string {\r\n    return this._accessToken\r\n  }\r\n\r\n  set accessToken(value: string) {\r\n    this._accessToken = value\r\n  }\r\n\r\n  /**\r\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\r\n   * the response.\r\n   *\r\n   * If you want your response to have historical context, you must provide a valid `parentMessageId`.\r\n   *\r\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\r\n   * If you want to receive the full response, including message and conversation IDs,\r\n   * you can use `opts.onConversationResponse` or use the `ChatGPTAPI.getConversation`\r\n   * helper.\r\n   *\r\n   * Set `debug: true` in the `ChatGPTAPI` constructor to log more info on the full prompt sent to the OpenAI completions API. You can override the `promptPrefix` and `promptSuffix` in `opts` to customize the prompt.\r\n   *\r\n   * @param message - The prompt message to send\r\n   * @param opts.conversationId - Optional ID of a conversation to continue (defaults to a random UUID)\r\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation (defaults to `undefined`)\r\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\r\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\r\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\r\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n   *\r\n   * @returns The response from ChatGPT\r\n   */\r\n  async sendMessage(\r\n    text: string,\r\n    opts: types.SendMessageBrowserOptions = {}\r\n  ): Promise<types.ChatMessage> {\r\n    if (!!opts.conversationId !== !!opts.parentMessageId) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: conversationId and parentMessageId must both be set or both be undefined'\r\n      )\r\n    }\r\n\r\n    if (opts.conversationId && !isValidUUIDv4(opts.conversationId)) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: conversationId is not a valid v4 UUID'\r\n      )\r\n    }\r\n\r\n    if (opts.parentMessageId && !isValidUUIDv4(opts.parentMessageId)) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: parentMessageId is not a valid v4 UUID'\r\n      )\r\n    }\r\n\r\n    if (opts.messageId && !isValidUUIDv4(opts.messageId)) {\r\n      throw new Error(\r\n        'ChatGPTUnofficialProxyAPI.sendMessage: messageId is not a valid v4 UUID'\r\n      )\r\n    }\r\n\r\n    const {\r\n      conversationId,\r\n      parentMessageId = uuidv4(),\r\n      messageId = uuidv4(),\r\n      action = 'next',\r\n      timeoutMs,\r\n      onProgress\r\n    } = opts\r\n\r\n    let { abortSignal } = opts\r\n\r\n    let abortController: AbortController = null\r\n    if (timeoutMs && !abortSignal) {\r\n      abortController = new AbortController()\r\n      abortSignal = abortController.signal\r\n    }\r\n\r\n    const body: types.ConversationJSONBody = {\r\n      action,\r\n      messages: [\r\n        {\r\n          id: messageId,\r\n          role: 'user',\r\n          content: {\r\n            content_type: 'text',\r\n            parts: [text]\r\n          }\r\n        }\r\n      ],\r\n      model: this._model,\r\n      parent_message_id: parentMessageId\r\n    }\r\n\r\n    if (conversationId) {\r\n      body.conversation_id = conversationId\r\n    }\r\n\r\n    const result: types.ChatMessage = {\r\n      role: 'assistant',\r\n      id: uuidv4(),\r\n      parentMessageId: messageId,\r\n      conversationId,\r\n      text: ''\r\n    }\r\n\r\n    const responseP = new Promise<types.ChatMessage>((resolve, reject) => {\r\n      const url = this._apiReverseProxyUrl\r\n      const headers = {\r\n        ...this._headers,\r\n        Authorization: `Bearer ${this._accessToken}`,\r\n        Accept: 'text/event-stream',\r\n        'Content-Type': 'application/json'\r\n      }\r\n\r\n      if (this._debug) {\r\n        console.log('POST', url, { body, headers })\r\n      }\r\n\r\n      fetchSSE(\r\n        url,\r\n        {\r\n          method: 'POST',\r\n          headers,\r\n          body: JSON.stringify(body),\r\n          signal: abortSignal,\r\n          onMessage: (data: string) => {\r\n            if (data === '[DONE]') {\r\n              return resolve(result)\r\n            }\r\n\r\n            try {\r\n              const convoResponseEvent: types.ConversationResponseEvent =\r\n                JSON.parse(data)\r\n              if (convoResponseEvent.conversation_id) {\r\n                result.conversationId = convoResponseEvent.conversation_id\r\n              }\r\n\r\n              if (convoResponseEvent.message?.id) {\r\n                result.id = convoResponseEvent.message.id\r\n              }\r\n\r\n              const message = convoResponseEvent.message\r\n              // console.log('event', JSON.stringify(convoResponseEvent, null, 2))\r\n\r\n              if (message) {\r\n                let text = message?.content?.parts?.[0]\r\n\r\n                if (text) {\r\n                  result.text = text\r\n\r\n                  if (onProgress) {\r\n                    onProgress(result)\r\n                  }\r\n                }\r\n              }\r\n            } catch (err) {\r\n              // ignore for now; there seem to be some non-json messages\r\n              // console.warn('fetchSSE onMessage unexpected error', err)\r\n            }\r\n          }\r\n        },\r\n        this._fetch\r\n      ).catch((err) => {\r\n        const errMessageL = err.toString().toLowerCase()\r\n\r\n        if (\r\n          result.text &&\r\n          (errMessageL === 'error: typeerror: terminated' ||\r\n            errMessageL === 'typeerror: terminated')\r\n        ) {\r\n          // OpenAI sometimes forcefully terminates the socket from their end before\r\n          // the HTTP request has resolved cleanly. In my testing, these cases tend to\r\n          // happen when OpenAI has already send the last `response`, so we can ignore\r\n          // the `fetch` error in this case.\r\n          return resolve(result)\r\n        } else {\r\n          return reject(err)\r\n        }\r\n      })\r\n    })\r\n\r\n    if (timeoutMs) {\r\n      if (abortController) {\r\n        // This will be called when a timeout occurs in order for us to forcibly\r\n        // ensure that the underlying HTTP request is aborted.\r\n        ;(responseP as any).cancel = () => {\r\n          abortController.abort()\r\n        }\r\n      }\r\n\r\n      return pTimeout(responseP, {\r\n        milliseconds: timeoutMs,\r\n        message: 'ChatGPT timed out waiting for response'\r\n      })\r\n    } else {\r\n      return responseP\r\n    }\r\n  }\r\n}\r\n","const uuidv4Re =\r\n  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\r\n\r\nexport function isValidUUIDv4(str: string): boolean {\r\n  return str && uuidv4Re.test(str)\r\n}\r\n"],"mappings":"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","names":["openai","fetch","fetch","_a","message","res","prompt","pTimeout","uuidv4","fetch","uuidv4","text","pTimeout"]}